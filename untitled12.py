# -*- coding: utf-8 -*-
"""Untitled12.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dEEWh-xqMn3M2dG_uuVFhqL5nXJn7Cch
"""

# Python Linter Tool based on custom rules (Rules 1â€“40)
# This tool scans .py files for rule violations using regex and AST

import ast
import os
import re
import sys

# Rule definitions as (description, detection_function)
RULES = []

# -- Rule helper functions --

def check_print_statements(tree):
    for node in ast.walk(tree):
        if isinstance(node, ast.Call) and getattr(node.func, 'id', '') == 'print':
            yield node.lineno, "Avoid using print() in library code; use logging instead."

def check_global_usage(tree):
    for node in ast.walk(tree):
        if isinstance(node, ast.Global):
            yield node.lineno, "Avoid excessive use of global variables."

def check_mutable_defaults(tree):
    for node in ast.walk(tree):
        if isinstance(node, ast.FunctionDef):
            for default in node.args.defaults:
                if isinstance(default, (ast.List, ast.Dict, ast.Set)):
                    yield node.lineno, "Avoid mutable default arguments like [], {}."

def check_bare_except(tree):
    for node in ast.walk(tree):
        if isinstance(node, ast.ExceptHandler) and node.type is None:
            yield node.lineno, "Avoid using bare 'except:'; catch specific exceptions."

def check_is_none(tree):
    for node in ast.walk(tree):
        if isinstance(node, ast.Compare):
            for op in node.ops:
                if isinstance(op, (ast.Eq, ast.NotEq)):
                    for comparator in node.comparators:
                        if isinstance(comparator, ast.Constant) and comparator.value is None:
                            yield node.lineno, "Use 'is' or 'is not' for None checks, not '=='."

def check_unused_imports(source):
    pattern = re.compile(r'^import\s+(\w+)|from\s+(\w+)\s+import', re.MULTILINE)
    for match in pattern.finditer(source):
        mod = match.group(1) or match.group(2)
        if mod and mod not in source.split(match.group(0))[-1]:
            yield match.start(), f"Unused import: {mod}"

# -- Register rule checkers --
RULES.append(check_print_statements)
RULES.append(check_global_usage)
RULES.append(check_mutable_defaults)
RULES.append(check_bare_except)
RULES.append(check_is_none)

# -- File scanning --
def lint_file(filepath):
    with open(filepath, 'r', encoding='utf-8') as f:
        source = f.read()

    try:
        tree = ast.parse(source)
    except SyntaxError as e:
        print(f"[SYNTAX ERROR] {filepath}:{e.lineno} - {e.msg}")
        return

    for rule in RULES:
        for lineno, message in rule(tree):
            print(f"[LINT] {filepath}:{lineno} - {message}")

    for char_pos, message in check_unused_imports(source):
        line_num = source[:char_pos].count('\n') + 1
        print(f"[LINT] {filepath}:{line_num} - {message}")

# -- Directory scanning --
def lint_directory(directory):
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith('.py'):
                lint_file(os.path.join(root, file))

# -- Main CLI --
if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("Usage: python linter.py <file_or_directory>")
        sys.exit(1)

    target = sys.argv[1]
    if os.path.isdir(target):
        lint_directory(target)
    else:
        lint_file(target)